var tmp[9]

var _camera.heartbeat = 50
var camera.detect[5] = [0, 0, 0, 0, 0]
var camera.thing[60]

# Constant QUEUE = 7

var Qid[7]   # = [ 0,0,0,0 ] ##!< [out] task id
var Qtime[7] # = [ 0,0,0,0 ] ##!< [out] remaining time
var QspL[7]  # = [ 0,0,0,0 ] ##!< [out] motor speed L
var QspR[7]  # = [ 0,0,0,0 ] ##!< [out] motor speed R
var Qpc = 0                    ##!< [out] program counter
var Qnx = 0                    ##!< [out] next pc

var base = 60	 # base speed
var speed = 0
var black = 300
var lost = 0
var lost_turn[2] = [200,  -350]
var lost_phase

var state = 0  # 0 = follow track; 1 = searching; 2 = tracking az; 3 = tracking el
var searching = 0
var tracking_kind
var tracking_ticks = 0

call math.fill(Qid, 0)
call math.fill(Qtime,0)
call math.fill(QspL,0)
call math.fill(QspR,0)

mic.threshold = 12

# Main event

sub doit
	# -- specialized: add default behavior here
	if state == 0 then
		callsub state0_follow_track
	elseif state == 1 then
		# searching for the target
		callsub state1_searching
	elseif state == 2 then
		# found target, tracking az
		callsub state2_tracking_az
	elseif state == 3 then
		# tracked az, tracking el
		callsub state3_tracking_el
	elseif state == 4 then
		# wait to retrace
		callsub state4_retrace
	end

# Following

sub state0_follow_track
	if speed > 0 then
		if  prox.ground.delta[0] < black and prox.ground.delta[1] < black then
			motor.left.target = speed
			motor.right.target = speed
			lost = 0
		elseif  prox.ground.delta[0] < black and prox.ground.delta[1] >= black then
			motor.left.target = speed
			motor.right.target = 4 * speed
			lost = 0
		elseif  prox.ground.delta[0] >= black and prox.ground.delta[1] < black then
			motor.left.target = 4 * speed
			motor.right.target = speed
			lost = 0
		elseif  prox.ground.delta[0] >= black and prox.ground.delta[1] >= black then
			lost = lost + 1
			if  lost > 400 then
				callsub do_stop
			end
			lost_phase = (lost / 100) % 2
			motor.left.target = lost_turn[lost_phase]
			motor.right.target = lost_turn[1 - lost_phase]
			# tmp[0:3] = [6,120,137,-137]
			# callsub motion_add
		end
	else
		motor.left.target = 0
		motor.right.target = 0
	end
	leds.bottom.left = [0, 0,0]
	leds.bottom.right = [0, 0, 0]


# Tracking

sub state1_searching
	# searching for the target
	searching = searching + 1
	motor.left.target = 70 * ((((searching / 1000) % 2) * -2) + 1)
	motor.right.target = - motor.left.target
	leds.bottom.left = [0, 0, ((motor.right.target / 70) + 1) * 100]
	leds.bottom.right = [0, 0, ((motor.left.target / 70) + 1) * 100]
	if camera.thing[tracking_kind * 4] > 20 then
		state = 2
	end

sub state2_tracking_az
	# found target, tracking az
	if abs(camera.thing[tracking_kind * 4 + 2]) < 20 then
		state = 3
		tracking_ticks = 0
		motor.left.target = 0
		motor.right.target = 0
	else
		# continue turning, don't change motors
	end
	leds.bottom.left = [200, 200,0]
	leds.bottom.right = [200, 200, 0]

sub state3_tracking_el
	# tracked az, tracking el
	tracking_ticks = tracking_ticks + 1
	if abs(camera.thing[tracking_kind * 4 + 3]) < 10 then
		tmp[0:3] = [10,133,-192,-192]  # 80 mm
		callsub motion_add
		tmp[0:3] = [11, 2*180, 137,-137]  # 180 degrees
		callsub motion_add
		tracking_ticks = (tracking_ticks / 2) - 120
		tmp[0:3] = [12, tracking_ticks, 140, 140]  # retrace steps
		callsub motion_add
		state = 4
	else
		motor.left.target = 70
		motor.right.target = 70
	end
	leds.bottom.left = [0, 200,0]
	leds.bottom.right = [0, 200, 0]

sub state4_retrace
	# wait for return
	if Qnx == Qpc then
		state = 0
	end

# Inputs

onevent tap
	event.args[0] = [87]
	callsub do_command

onevent rc5
	event.args[0] = [rc5.command]
	callsub do_command

# -- specialized
onevent camera.detect
	# -- specialized: add detection here
	if event.args[0] == 1
			or (event.args[0] >=3 and event.args[0] <= 6) 
			or event.args[0] == 11 or event.args[0] == 13 then
		# thing
		if event.args[4] < 150 then
			callsub do_sweep
		end
	elseif event.args[0] == 2 or event.args[0] == 10 then
		# nest or target
		if state == 1 then
			# state = 2
			tracking_kind = event.args[0]
		end
	elseif speed > 0 then
		if event.args[0] == 7 or event.args[0] == 8 then
			# turn ahead
			callsub do_normal
		elseif event.args[0] == 9 and speed <= 200 then
			# straightaway
			callsub do_faster
		elseif event.args[0] == 12 then
			# stop sign
			callsub do_long_stop
		elseif event.args[0] == 14 then
			# zebra sign
			callsub do_short_stop
		elseif event.args[0] == 0 then
			# parking sign
			callsub do_stop
		end
	end

# commands
sub do_command
	# -- standard
	if event.args[0] == 87 then # stop
		call sound.system(1)
		callsub do_stop
		state = 0
	elseif event.args[0] == 53 then # go
		call sound.system(0)
		callsub do_normal
		state = 0
	elseif event.args[0] == 0 then # 0 = sweep
		callsub do_sweep
	elseif event.args[0] == 80 then # forward
		callsub do_forward
	elseif event.args[0] == 81 then # backward
		callsub do_backward
	elseif event.args[0] == 86 then # right
		callsub do_right
	elseif event.args[0] == 85 then # left
		callsub do_left
	elseif event.args[0] == 16 then # plus
		callsub do_faster
	elseif event.args[0] == 17 then # minus
		callsub do_normal
	# -- poweroff
	elseif event.args[0] == 8 then
		call _poweroff()
	# -- specialized: add commands here
	elseif event.args[0] == 1 then # 1 = state 1
		state = 1
		searching = 0
		camera.thing[8:11] = [0, 0, 0,0]
	elseif event.args[0] == 2 then # 2 = state 2
		# state = 2
		tracking_kind = 2
		camera.thing[8:11] = [90, 0, 100,100]
	elseif event.args[0] == 3 then # 3 = state 3
		# state = 3
		camera.thing[8:11] = [90, 0, 0,100]
	elseif event.args[0] == 4 then # 4 = state 4
		# state = 4
		camera.thing[8:11] = [90, 0, 0,9]
	elseif event.args[0] == 7 then # 7 = stop sign
		callsub do_long_stop
	elseif event.args[0] == 9 then # 9 = zebra
		callsub do_short_stop
	end

sub do_stop
	speed = 0
	callsub motion_reset

sub do_normal
	speed = base
	call sound.system(2)
	motor.left.target = speed
	motor.right.target = speed
	lost = 0

sub do_forward
	tmp[0:3] = [3, 100, 128, 128]  # 40 mm
	callsub motion_add

sub do_backward
	tmp[0:3] = [3, 100, -128,-128]  # 40 mm
	callsub motion_add

sub do_right
	tmp[0:3] = [2, 2*20, 137,-137]  # 20 degrees
	callsub motion_add

sub do_left
	tmp[0:3] = [2, 2 * 20, -137,137]  # 20 degrees
	callsub motion_add

sub do_faster
	speed = speed * 12 / 10
	call math.clamp(speed, speed, 0, 150)

sub do_sweep
	tmp[0:3] = [1,100,160,160]  # 50 mm
	callsub motion_add
	tmp[0:3] = [2,80,137,-137]  # 40 degrees
	callsub motion_add
	tmp[0:3] = [3,100,-160,-160]  # 50 mm
	callsub motion_add
	tmp[0:3] = [4,80,-137,137]  # 40 degrees
	callsub motion_add

# -- specialized: add commands here

sub do_long_stop
	tmp[0:3] = [5,300,0,0]
	callsub motion_add
	speed = base

sub do_short_stop
	tmp[0:3] = [5,100,0,0]
	callsub motion_add
	speed = base

# Standard

# Motion queue

onevent motor # loop runs at 100 Hz
if Qtime[Qpc] > 0 then
	# start new motion
#	emit Q_motion_started([Qid[Qpc], Qtime[Qpc], QspL[Qpc], QspR[Qpc], Qpc])
	Qtime[Qpc] = 0 - Qtime[Qpc] # mark as current by setting negative value
end
if Qtime[Qpc] < 0 then
	# continue motion
	leds.top = [180,180,0]
	motor.left.target = QspL[Qpc]
	motor.right.target = QspR[Qpc]
	Qtime[Qpc] += 1
	if Qtime[Qpc] == 0 then
#		emit Q_motion_ended([Qid[Qpc], Qtime[Qpc], QspL[Qpc], QspR[Qpc], Qpc])
		Qid[Qpc] = 0
		Qpc = (Qpc+1)%7
		if Qtime[Qpc] == 0 and Qpc == Qnx then
#			emit Q_motion_noneleft([Qpc])
			motor.left.target = 0
			motor.right.target = 0
		end
	end
end
if Qtime[Qpc] == 0 and Qpc != Qnx then
	# scan forward in the queue
	Qpc = (Qpc+1)%7
end
callsub update_leds
# if queue is empty do behavior
if Qnx == Qpc then
	callsub doit
end

sub update_leds
	if  speed == 0 then
		leds.top = [200,0,0]
	else
		leds.top = [0,200,0]
	end
	# leds.buttons show queue
	call math.fill(tmp,0)
	tmp[Qnx]=1
	tmp[Qpc]=4
	call leds.buttons(tmp[0],tmp[1],tmp[2],tmp[3])
	# leds.circle show speed
	call math.div(tmp[0:4],  [speed,speed,speed,speed,speed],  [60,72,86,103,123])
	call math.clamp(tmp[0:4],  tmp[0:4],  [0,0,0,0,0],  [1,1,1,1,1])
	call math.mul(leds.circle[0:4],  tmp[0:4],  [30,30,30,30,30])

##! @brief Subroutine to add a task to the queue
##! @private
##! @param Qid task id
##! @param Qtime time in 100ths
##! @param QspL left motor speed
##! @param QspR right motor speed
sub motion_add
if (Qnx != Qpc or (Qnx == Qpc and Qtime[Qpc] == 0)) and Qid[0]!=tmp[0] and Qid[1]!=tmp[0] and Qid[2]!=tmp[0] and Qid[3]!=tmp[0] then
	Qid[Qnx]   = tmp[0]
	Qtime[Qnx] = tmp[1]
	QspL[Qnx]  = tmp[2]
	QspR[Qnx]  = tmp[3]
#	emit Q_motion_added([Qid[Qnx], Qtime[Qnx], QspL[Qnx], QspR[Qnx], Qnx])
	Qnx = (Qnx+1)%7
# else silently ignore
end

##! @brief Subroutine to cancel a task from the queue
##! @private
##! @param Qid task id
sub motion_cancel
for tmp[1] in 1:7 do
	if Qid[tmp[1]-1] == tmp[0] then
#		emit Q_motion_cancelled([Qid[tmp[1]-1], Qtime[tmp[1]-1], QspL[tmp[1]-1], QspR[tmp[1]-1], tmp[1]-1])
		Qtime[tmp[1]-1] = -1 # on next motor trigger Q_motion_ended, Q_motion_noneleft
		# Qid[tmp[1]-1] = 0  # keep for Q_motion_ended, will be removed line 66
	end
end

##! @}

##! @defgroup Motion
##! @brief Incoming events to change motion queue: @c Q_*
##!
##! The REST API provides events for sending requests to the motion queue.
##! Note that the brief description line for each will be used as the Scratch block definition.
##!
##! Changes to the motion queue will be broadcast using events @c Q_motion_added,
##! @c Q_motion_cancelled, @c Q_motion_started, @c Q_motion_ended, @c Q_motion_noneleft.
##! @{

##! Add a task to the motion queue
##! @brief Q_add_motion job \%n for \%n csec, left \%n right \%n
##! @param Qid task id
##! @param Qtime time in 100ths
##! @param QspL left motor speed
##! @param QspR right motor speed
onevent Q_add_motion
tmp[0:3] = event.args[0:3]
callsub motion_add

##! Cancel a task in the motion queue
##! @brief Q_cancel_motion job \%n
##! @param Qid task id
onevent Q_cancel_motion
tmp[0] = event.args[0]
callsub motion_cancel

##! Reset the queue and stop motors
##!  @brief Q_reset
onevent Q_reset
callsub motion_reset

sub motion_reset
motor.left.target = 0
motor.right.target = 0
call math.fill(Qid,0)
call math.fill(Qtime,0)
call math.fill(QspL,0)
call math.fill(QspR,0)
call math.fill(Qpc,0)
call math.fill(Qnx,0)
# emit Q_motion_noneleft([Qpc])

##! Play a system sound
##! @brief A_sound_system \%n
##! @param sound system sound number
onevent A_sound_system
call sound.system(event.args[0])

##! Run the left motor
##! @brief M_motor_left \%n
##! @param speed
onevent M_motor_left
motor.left.target = event.args[0]

##! Run the right motor
##! @brief M_motor_right \%n
##! @param speed
onevent M_motor_right
motor.right.target = event.args[0]
